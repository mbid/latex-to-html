\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
% \usepackage[round]{natbib}
\usepackage[english]{babel}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{url}
\usepackage{hyperref}
\usepackage{tikz-cd}
\usepackage{mathtools}
% \usepackage{enumitem}
\usepackage{color}
\usepackage{mathpartir}

\mathtoolsset{showonlyrefs}

\newcommand{\todo}[1]{\textcolor{red}{#1}}

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

\begin{document}

\title{Eqlog: Datalog with functions and equality}

\author{Martin E. Bidlingmaier}

\date{}

\maketitle

\begin{abstract}
  We introduce eqlog, an extensions of datalog that supports function symbols and infers equalities.
  We show that eqlog encompasses precisely the finite essentially algebraic theories.
  An eqlog engine is then a tool to perform computations in (fragments of) free models of essentially algebraic theories.

  In the second part, we show how the semi-naive evaluation strategy of datalog can be combined with the standard congruence closure algorithm into an efficient algorithm for eqlog evaluation.
  We discuss several optimizations, and show how an eqlog can replace both standard datalog and e-graphs for their respective applications without algorithmic slowdown.

  The paper is accompanied by a tool that translates eqlog theories to specialized rust code.
\end{abstract}

\section{
  Essentially algebraic
}

In this section we recall the notion of \emph{ (finite) essentially algebraic theory } and give a brief proof sketch of the existence of free models.
Our proof proceeds by associating to each axiom $T$ of an essentially algebraic theory an epimorphic morphism $[T]$ in the category of structures for the signature of the theory.
We show that the models of the theory are precisely the orthogonal structures.
From this it follows via the orthogonal-reflection construction that a free model exists over every structure.

We then discuss relational signatures and theories.
Relational signatures do not have function symbols.
Every algebraic signature induces a relational signature by associating to every function symbol a relation symbol representing the graph.
The algebraic structures can then again be obtained as an orthogonality class in the category of relational structures.

We then introduce relational theories.
We again associate morphism $[T]$ of relational structures to every relational axiom $T$.
In contrast to the algebraic case, $[T]$ need not always be an epimorphism, so the orthogonal-reflection construction does not directly apply.
However, we show how algebraic theories can be encoded as relational theories, for which an adaptation of the orthogonal-reflection reaches a fixed point.
This construction is the basis of the eqlog algorithm.

\subsection{The orthogonal-reflection construction}
\label{subsec:orthogonal-reflection}

Fix a cocomplete category $\mathcal{C}$ for the remainder of Section \ref{subsec:orthogonal-reflection}.

\begin{definition}
  Let $f : A \rightarrow B$ be a morphism let $X$ be an object.
  We write $f \pitchfork X$ and say that $X$ is \emph{injective} to $f$ if for all maps $a : A \rightarrow X$, there exists a map $b : B \rightarrow X$ such that
  \begin{equation}
    \begin{tikzcd}
      A \arrow[r, "a"] \arrow[d, "f"'] & X \\
      B \arrow[ur, dashed, "\exists b"']
    \end{tikzcd}
  \end{equation}
  commutes.
  If furthermore $b$ is unique for all $a$, then we write $f \perp X$ and say that $X$ is \emph{orthogonal} to $f$.

  If $M$ is a class of morphisms, then we write $M \pitchfork X$ if $f \pitchfork X$ for all $f \in M$, and $M \perp X$ if $f \perp X$ for all $f \in M$.
  The full subcategories given by the injective and orthogonal objects, respectively, are denoted by $M^\pitchfork$ and $M^\perp$.
  % This notation is also used in Adamek-Rosicky.
\end{definition}

\begin{definition}
  \label{def:flub}
  A class $M$ of morphisms is called \emph{flub} if $M^\pitchfork = M^\perp$.
\end{definition}

One of the main sources of flub sets is the following Lemma:
\begin{lemma}
  Let $M$ be a class of epimorphisms.
  The $M$ is flub.
  \qed
\end{lemma}

The other one is the following proposition.
It lets us reduce questions about orthogonality classes to flub injectivity classes.
\begin{proposition}
	Let $M$ be a class of morphisms.
	Then there exists a superclass $N \supseteq M$ such that $N$ is flub and $N^\pitchfork = M^\perp$.
  If $M$ is a set, then $N$ can be chosen as set.
\end{proposition}

% \bibliographystyle{abbrvnat}
% \setcitestyle{authoryear,open={(},close={)}}
% \bibliography{main}

\end{document}
